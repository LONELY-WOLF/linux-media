using System.Runtime.InteropServices;

namespace LinuxMedia.Rockchip
{
    [StructLayout(LayoutKind.Sequential)]
    internal struct MppApi
    {
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int OnePtr_Delegate(IntPtr ptr1);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int TwoPtr_In_Delegate(IntPtr ptr1, IntPtr ptr2);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int TwoPtr_Out_Delegate(IntPtr ptr1, ref IntPtr ptr2);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int ThreePtr_In_Delegate(IntPtr ptr1, IntPtr ptr2, IntPtr ptr3);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int ThreePtr_Out_Delegate(IntPtr ptr1, IntPtr ptr2, ref IntPtr ptr3);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int PtrIntPtr_In_Delegate(IntPtr ptr1, int i1, IntPtr ptr2);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int PtrIntPtr_Out_Delegate(IntPtr ptr1, int i1, ref IntPtr ptr2);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        internal delegate int PtrIntInt_Delegate(IntPtr ptr1, int i1, int i2);

        /// <summary>
        /// size of struct MppApi
        /// </summary>
        public UInt32 size;
        /// <summary>
        /// mpp api version, generated by Git
        /// </summary>
        public UInt32 version;

        // simple data flow interface
        /**
         * @brief both send video stream packet to decoder and get video frame from
         *        decoder at the same time
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] packet The input video stream, its usage can refer mpp_packet.h.
         * @param[out] frame The output picture, its usage can refer mpp_frame.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET (*decode)(MppCtx ctx, MppPacket packet, MppFrame* frame);</c>
        /// </summary>
        internal ThreePtr_Out_Delegate decode;
        /**
         * @brief send video stream packet to decoder only, async interface
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] packet The input video stream, its usage can refer mpp_packet.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*decode_put_packet)(MppCtx ctx, MppPacket packet);</c>
        /// </summary>
        internal TwoPtr_In_Delegate decode_put_packet;
        /**
         * @brief get video frame from decoder only, async interface
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[out] frame The output picture, its usage can refer mpp_frame.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*decode_get_frame)(MppCtx ctx, MppFrame* frame);</c>
        /// </summary>
        internal TwoPtr_Out_Delegate decode_get_frame;
        /**
         * @brief both send video frame to encoder and get encoded video stream from
         *        encoder at the same time
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] frame The input video data, its usage can refer mpp_frame.h.
         * @param[out] packet The output compressed data, its usage can refer mpp_packet.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*encode)(MppCtx ctx, MppFrame frame, MppPacket* packet);</c>
        /// </summary>
        internal ThreePtr_Out_Delegate encode;
        /**
         * @brief send video frame to encoder only, async interface
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] frame The input video data, its usage can refer mpp_frame.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*encode_put_frame)(MppCtx ctx, MppFrame frame);</c>
        /// </summary>
        internal TwoPtr_In_Delegate encode_put_frame;
        /**
         * @brief get encoded video packet from encoder only, async interface
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[out] packet The output compressed data, its usage can refer mpp_packet.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*encode_get_packet)(MppCtx ctx, MppPacket* packet);</c>
        /// </summary>
        internal TwoPtr_Out_Delegate encode_get_packet;

        /**
         * @brief ISP interface, will be supported in the future.
         */
        /// <summary>
        /// <c>MPP_RET(*isp)(MppCtx ctx, MppFrame dst, MppFrame src);</c>
        /// </summary>
        internal ThreePtr_In_Delegate isp;
        /**
         * @brief ISP interface, will be supported in the future.
         */
        /// <summary>
        /// <c>MPP_RET(*isp_put_frame)(MppCtx ctx, MppFrame frame);</c>
        /// </summary>
        internal TwoPtr_In_Delegate isp_put_frame;
        /**
         * @brief ISP interface, will be supported in the future.
         */
        /// <summary>
        /// <c>MPP_RET(*isp_get_frame)(MppCtx ctx, MppFrame* frame);</c>
        /// </summary>
        internal TwoPtr_Out_Delegate isp_get_frame;

        // advance data flow interface
        /**
         * @brief poll port for dequeue
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] type input port or output port which are both for data transaction
         * @param[in] timeout mpp poll type, its usage can refer mpp_task.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*poll)(MppCtx ctx, MppPortType type, MppPollType timeout);</c>
        /// </summary>
        internal PtrIntInt_Delegate poll;

        /**
         * @brief dequeue MppTask, pop a task from mpp task queue
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] type input port or output port which are both for data transaction
         * @param[out] task MppTask popped from mpp task queue, its usage can refer mpp_task.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*dequeue)(MppCtx ctx, MppPortType type, MppTask* task);</c>
        /// </summary>
        internal PtrIntPtr_Out_Delegate dequeue;
        /**
         * @brief enqueue MppTask, push a task to mpp task queue
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] type input port or output port which are both for data transaction
         * @param[in] task MppTask which is sent to mpp for process, its usage can refer mpp_task.h.
         * @return 0 and positive for success, negative for failure. The return
         *         value is an error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*enqueue)(MppCtx ctx, MppPortType type, MppTask task);</c>
        /// </summary>
        internal PtrIntPtr_In_Delegate enqueue;

        // control interface
        /**
         * @brief discard all packet and frame, reset all component,
         *        for both decoder and encoder
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @return 0 for success, others for failure. The return value is an
         *         error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*reset)(MppCtx ctx);</c>
        /// </summary>
        internal OnePtr_Delegate reset;
        /**
         * @brief control function for mpp property setting
         * @param[in] ctx The context of mpp, created by mpp_create() and initiated
         *                by mpp_init().
         * @param[in] cmd The mpi command, its definition can refer rk_mpi_cmd.h.
         * @param[in,out] param The mpi command parameter
         * @return 0 for success, others for failure. The return value is an
         *         error code. For details, please refer mpp_err.h.
         */
        /// <summary>
        /// <c>MPP_RET(*control)(MppCtx ctx, MpiCmd cmd, MppParam param);</c>
        /// </summary>
        internal PtrIntPtr_In_Delegate control;
        /**
         * @brief The reserved segment, may be used in the future
         */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        UInt32[] reserv;
    }

    public struct MppBufferInfo
    {
        public MppBufferType type;
        public UInt64 size;
        public IntPtr ptr;
        public IntPtr hnd;
        public int fd;
        public int index;
    }
}
